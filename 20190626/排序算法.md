# 排序算法

## 插入排序类

### 直接插入排序

- 时间复杂度O(n^2)
- 核心思想

	- 将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表

### 希尔排序

- 时间复杂度为：O(n^(3/2))
- 核心思想

	- 将原数据集合分割成若干个子序列，然后再对子序列分别进行直接插入排序，使子序列基本有序，最后再对全体记录进行一次直接插入排序。

## 选择排序类

### 简单选择排序

- 时间复杂度O(n^2)
- 核心思想

	- 通过n-i次关键字之间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1<=i<=n)个记录进行交换。

### 堆排序

- 时间复杂度为：O(nlogn)
- 核心思想

	- 将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆的根节点。将它与堆数组的末尾元素交换，然后将剩余的n-1个序列重新构造成一个大顶堆。反复执行前面的操作，最后获得一个有序序列。

## 交换排序类

### 冒泡排序

- 时间复杂度O(n^2)
- 核心思想

	- 两两比较相邻记录的关键字，如果反序则交换，直到没有反序记录为止。

### 快速排序

- 时间复杂度为O(nlog(n))
- 核心思想

	- 通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分继续进行排序，以达到整个记录集合的排序目的。

## 归并排序

### 时间复杂度为O(nlogn)

### 核心思想

- 建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

### 归并排序是一种比较占用内存，但效率高，并且稳定的算法。

*XMind: ZEN - Trial Version*